# 1. 포인터 시작하기   
### 1. 포인터란?   
포인터는 메모리의 주소를 가지고 있는 변수이다. 포인터는 변수가 저장되는 주소와 관계가 있다.   
쉽게 말하자면 포인터는 변수이지만, 보통 변수처럼 데이터가 아니라 변수의 주소를 저장하고 있다.   
정수를 가리키는 포인터는 다음과 같이 정의된다.   
```c
int *p; //정수를 가리키는 포인터
```
포인터는 사용하기 전에 반드시 초기화를 하여야 한다. 포인터에는 변수의 주소가 저장되어야 하므로 & 연산자르 이용하여 변수의 주소를 계산하여 포인터에 대입하여 주면 된다.
```c
int num = 10; // 정수형 변수 num 선언
int *p; // 포인터 p 선언
p = &num; // 변수 numd의 주소가 포인터 p로 대입
```
포인터 p는 변수 num의 값이 아닌 주소값을 저장하고 있다.   
   
   
포인터는 지정된 자료형의 변수만을 가리킬 수 있다.
int형 포인터는 int형만을, char형 포인터는 char형 변수만을 가리킬 수 있다.     
즉, 포인터에도 자료형이 있다고 생각하면 된다.   

### 2. 간접 참조 연산자
포인터가 가리키는 위치에 저장된 내용을 가지고 오려면 p앞에 *를 붙이면 된다.   
이것을 포인터를 통하여 간접참조한다고 한다.
```c
int num = 10;
int *p;
p = &num;
printf("%d\n", *p);
```
위 코드의 결과는 10이다. 만약 *p가 아닌 p를 출력했다면, num의 주소값이 출력된다.
   
포인터 연산자에는 주소 연산자 &와 간접 참조 연산자*가 있다.    
간접 참조 연산자 *을 이용해서 포인터가 가리키는 변수의 값을 변경할 수 있다.   
예를 들어 위 코드에서 p를 통해 num의 값을 변경시키려면 아래와 같이 하면 된다.
- &연산자는 변수의 주소를 구하여 포인터에 대입할 때 사용한다.
- *연산자는 포인터를 통해 변수를 간접 참조할 때 사용한다.
```c
int num = 10;
int *p;
p = &num;
printf("%d\n", num); // 10 출력

*p = 20;
printf("%d\n", num); // 20 출력
printf("%d\n", *p); // 역참조 연산!
return 0;
```
역참조 연산자 *는 포인터 앞에 붙이고, 위 코드에서 처럼 *를 붙이면 p에 저장된 주소로 가서 값을 가져. 따라서 num의 값인 20이 출력된다.   

### 3. 포인터 연산   
포인터에 대해서는 덧셈과 뺄셈 연산만 있으면 가능하다.   
포인터 증가 연산에서 ++를 적용하였을 경우, 증가되는 값은 포인터가 가리키는 객체의 크기이다.   
따라서 char형 포인터를 증가시키면 char형 크기인 1바이트 만큼 증가하고, int형 포인터를 증가시키면 4바이트 만큼 증가한다.   
그러나 자료형과 상관 없이 포인터 변수는 주소이므로 포인터 변수의 크기는 전부 4이다. 
```c
char *pc;
int *pi;
double *pd;

pc = (char *)10000;
pi = (int *)10000;
pd = (double *)10000;
printf("%d %d %d\n", pc, pi, pd); // 10000 10000 10000 출력

pc++;
pi++;
pd++;
printf("%d %d %d\n", pc, pi, pd); // 10001 10004 10008 출력
```
### 4. 함수와 포인터
포인터를 사용하는 이유를 간단히 설명하면, 넘겨야하는 정보의 크기가 클 때, 정보를 모두 복사해서 넘기는 것보다 데이터 위치만 알려주는 것이 훨씬 효율적이라고 할 수 있다.   
따라서 프로그램에서도 데이터의 전부 복사가 아닌 데이터가 있는 위치를 포인터로 알려주는 것이다.    
함수가 데이터를 받는 방법에는 크게 2가지가 있는데, 값에 의한 호출과 참조에 의한 호출이다.  
- 값에 의한 호출: 함수가 호출될 때 복사본이 함수로 전달되면 값에 의한 호출이다. 함수 안에서 매개 변수를 변경하여도 원본에는 영향을 주지 않는다.   
- 참조에 의한 호출: 함수가 호출될 때 원본을 함수로 전달하는 방법이다. 함수 안에서 매개변수를 변경하면 원본 변수가 변경된다.   
C언어에서는 기본적으로 **값에 의한 호출** 만 가능하다. 즉, 함수 안에서 매개변수를 변경하더라도 원본 변수는 변경되지 않는다.   
하지만 포인터를 함수에 전달하면 "참조에 의한 호출"을 흉내낼 수 있다.   
```c
//값에 의한 호출 예
void func(int n){
   n=30; // 매개변수를 변경한다.
}

int main(){
   int num = 10;
   func(10);
   printf("%d", num); // 그대로 10 출력
   return 0;
}
```

```c
//참조에 의한 호출 예
void func(int *p){
   *p=30; // 매개변수를 변경한다.
}

int main(){
   int num = 10;
   func(&num); // 주소를 계산해서 보냄
   printf("%d", num); // 30 출력
   return 0;
}
```

* 간접 참조와 증감 연산자
*p++ : p를 증가시킨 후 이를 주소에 반영한다. (주소는 변경되고, 내용은 변경되지 않음)   
(*p)++ : 우선 p의 내용을 가져온 후 값을 증가시킨다. (주소는 변경되지 않고, 내용은 변경됨)   
*++p : 주소를 증가시킨 후 이를 반영한다. (주소는 변경되고 내용은 변경되지 않음)   
++*p : 내용을 가져온 후 값을 증가시킨다. (주소는 변경되지 않고, 내용은 변경된다.)
   
|     | *p++ | (*p)++ | *++p | ++*p |
|---|:---:|:---:|:---:|---:|
주소 | 변경 | 변경X | 변경 | 변경X |
내용 | 변경X | 변경 | 변경X | 변경 |
   
C언어에서 swap 함수를 만들려면, 인자를 값이 아닌 주소를 전달해야 한다.
```c
void swap(int *pa, *pb){
   tmp = *pa;
   *pa = *pb;
   *pb = tmp;
}
```

### 5. 포인터 산술 연산
- 포인터 덧셈
포인터끼리의 덧셈은 허용되지 않는다. 포인터는 주소값을 저장하므로, 주소값의 합은 어떤 의미도 갖지 않기 때문이다.
```c
int *pa = (int *)10;
int *pb = (int *)20;
int *psum = pa + pb; // error
```
- 포인터 뺄셈
포인터끼리의 뺄셈은 의미가 있는데, 마지막 주소와 시작 주소의 포인터 값을 빼면, 할당된 메모리의 크기를 알 수 있다. 
앞서 설명했듯이, 반드시 데이터 타입을 지켜야 한다. int면 int, char이면 char, double이면 double..
```c
int arr[?] = {1,2,3,4, ...};

int *p_first; // 시작 주소
int *p_last // 마지막 주소
int size;
size = *p_last - *p_first + 1;

```
### 6. 다중 포인터
다중 포인터는 간접 지정 연산을 두번 이상 하는 것이다. int*형은 단일 포인터이고 int**형은 이중 포인터이다. 
int*의 타입은 int형으로 int**형은 int*형이 된다.   
```c
int n = 10;
int *p1 = &n;
int **p2 = &p1;

printf("%p\n", p1); // n의 주소값 출력
printf("%p\n", *p2); // n의 주소값 출력
<pre>
