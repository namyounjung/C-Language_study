# 3. 포인터와 함수
포인터는 함수로 데이터를 전달하거나 함수에 의해 데이터를 수정할 수 있게 한다.   
또 포인터가 데이터 타입이 아닌 함수의 주소를 가리키는 경우, 포인터는 프로그램의 실행 흐름을 동적으로 제어하는데 사용될 수 있다.   
### 1. 프로그램의 스택과 힙
##### 프로그램 스택?
프로그램 스택은 함수의 실행을 지원하기 위한 메모리 영역이며, 일반적으로 힙과 공유된다.   
즉, 프로그램의 스택과 힙은 같은 메모리 영역을 공유한다.    
공유된 메모리 영역에서 프로그램 스택은 낮은 부분을 사용하려는 경향이 있고, 힙은 메모리의 높은 부분을 사용한다.
이러한 프로그램 스택은 스택 프로그램을 포함하고 있으며, 활성화 레코드나 활성화 프레임으로 불리기도 한다.   
메모리가 동적으로 할당되면 힙 영역을 사용하며, 힙영역은 아래로 자라는 경향이 있다.   

### 2. 포인터에 의한 전달과 반환
포인터를 함수로 전달하면 해당 개체를 전역으로 만들지 않고도 다양한 함수에서 참조할 수 있다.   
그리고 데이터를 포인터로 전달하면서 해당 포인터를 상수 포인터로 전달하면 함수 내에서 데이터가 수정되는 것을 방지할 수 있다.   
다음 코드는 swap 기능을 구성하는 코드이다.
```c
void swap(int* pa, *pb){
  int tmp;
  tmp = *pa;
  *pa = *pb;
  *pb = tmp;
}

int main(){
  int n = 5;
  int m = 10;
  swap(&n, &m);
  return 0;
}
```
포인터 pa와 pb는 swap동작 하는 동안 역참조되며, 그 결과 변수의 값이 서로 뒤바뀐다.   
pa와 pb가 가리키는 변수의 주소값은 변하지 않는다.   
그러나 값에 의한 전달은 포인터가 아닌 값으로 전달되어 복사해서 전달하는 것이기 때문에 교환동작이 일어나지 않는다.   
   
### 3. 상수 포인터 전달하기
상수 포인터 전달은 구조체와 같은 큰 데이터를 함수로 전달할 때 많은 메모리의 복사를 피하고 데이터의 주소만 전달하는 효과적인 방법이다.   
단순히 포인터만을 전달하는 것은 전달된 데이터가 수정될 수 있다. 데이터의 수정이 필요하지 않은 경우라면 상수 포인터 전달이 효과적이다.   
```c
void func(const int* pa, *pb){ 
  *pb = *pa;
}

int main(){
  const int n = 5;
  int m = 10;
  func(&n, &m); //m에 5할당. 하지만 그 반대의 경우는 불가
  return 0;
}
```
포인터를 사용하고 난 후에는 메모리 누수 방지를 위해 포인터 해제가 필요하다.   
free 함수는 전달된 포인터가 NULL인지 검사하지 않으므로, 메모리 해제 후 포인터를 NULL로 설정하는 것이 좋다.   
   
### 4. 로컬 데이터 포인터
프로그램 스택의 동작 방식을 이해하지 못할 경우, 로컬 데이터 포인터를 반환하는 실수를 할 수 있다.
```c
int* array(int n, int m){
  int arr[n];
  for(int i=0; i<n; i++) arr[i] = m;
  return arr;
}

int main(){
int* v = array(5, 45);
for(int i=0; i<5; i++) printf(""%d", v[i]);
...
}
```
위 코드에서 배열의 주소는 함수가 반환되는 즉시 함수의 스택 프레임에서 제거된다.   
스택 프레임이 스택에서 제거되더라도 메모리상 배열 요소는 m값을 포함하지만, 다른 함수 호출 시 덮어 쓰여진다.   
이와 같은 경우에 변수 arr을 static으로 선언하면 변수가 스택프레임 바깥에 할당되어 다른 함수가 변수의 값을 덮어쓸 가능성이 사라진다.   
   
### 5. 포인터의 포인터 전달하기
포인터가 함수로 전달되면, 포인터는 값에 의해 함수로 전달된다.   
호출된 함수 내에서 포인터의 복사본이 아닌 포인터 자체를 수정하길 원하면 포인터의 포인터를 전달해야 한다.
```c
//정상 동작 코드
void func(int **arr, int n, int m){
  *arr = (int*)malloc(n*sizeof(int));
  if(arr != NULL)
    for(int i=0;i<n;i++) *(*arr+i) = m;
}

int main(){
  int *v = NULL;
  func(&v, 5, 45); //포인터의 포인터 전달
  printf("%p\n", v);
  ...
}  
```
다음은 동작하지 않는 비정상 코드이다.
```c
//정상 동작하지 않는 코드
void func(int *arr, int n, int m){
  arr = (int*)malloc(n*sizeof(int));
  if(arr != NULL)
    for(int i=0;i<n;i++) arr[i] = m;
}

int main(){
  int *v = NULL;
  func(&v, 5, 45); 
  printf("%p\n", v);
  ...
}  
```
위 코드를 실행하면 0이 출력되는데, 이러한 결과가 나오는 이유는 v 변수가 함수에 전달될 때 매개변수 arr로 복사되어 전달되기 때문에 실제 값에 영향을 미치지 않는다.   
또한 함수가 반환되어도 arr변수에 저장된 값이 v에 복사되지 않는다.   

### 6. 함수 포인터
함수 포인터는 함수의 주소를 가리키는 포인터이다. 함수 포인터는 어떠한 조건 문장도 사용하지 않고서 컴파일 시간에 미리 결정된 순서가 아닌 함수의 실행을 제어하는 방법을 제공한다.   
```c
void (*foo)();

void - 반환값
*foo - 함수 포인터의 변수 이름
() - 매개변수
```

```c
int (*f1)(double); // double을 인자로 받고 int 반환
void (*f2)(char*); // char 포인터를 전달받고, void 반환
double* (*f3)(int, int); // 두 개의 정수를 전달받고, double 포인터 반환
```
함수 **포인터**와 포인터를 반환하는 **함수**를 혼동하지 말아야 한다.
```c
int *f1(); // 정수 포인터를 반환하는 함수의 선언
int* f1(); // 위와 같은 것을 재배열한 것임.
int (*f2)(); // 정수를 반환하는 함수 포인터의 선언
```
