# 7. 포인터와 문자열
### 1. 문자열 기초
문자열은 아스기 NULL문자로 끝나는 연속된 문자의 집합이다.   
문자열은 일반적으로 배열 또는 힙에 할당된 메모리에 저장된다.   
모든 문자의 배열이 문자열인 것은 아니다. 문자의 배열에는 아스키 NULL 문자가 포함되지 않을 수 있다.   
문자열의 길이는 문자열에 포함된 문자의 수와 같으며, **\0 문자는 포함되지 않는다.**   
C언어에서 문자 상수는 정수 타입이다.
```c
printf("%d\n", sizeof(char)); // 1
printf("%d\n", sizeof('a')); // 4
```
   
- 문자열 선언   
* 리터럴로 선언(문자열 상수)   
* 문자의 배열로 선언   
* 문자에 대한 포인터로 선언   
문자열 상수는 "큰 따옴표로 둘러싸여있으며, 문자 상수는 '작은 따옴표에 둘러싸여있다.   
   
- 문자열 리터럴 풀
리터럴 문자열은 종종 리터럴 풀에 할당된다. 리터럴 풀은 문자열을 구성하는 문자 배열을 저장한다.   
리터럴 문자열이 한 번 이상 사용되면, 일반적으로는 하나의 복사본만이 리터럴 풀에 존재한다.   
따라서 애플리케이션에서 사용하는 메모리 공간을 절약할 수 있다.   
일반적으로 리터럴은 변경할 수 없어서 하나의 복사본만 존재해도 문제가 되지 않는다.   
문자열 리터럴은 종종 읽기 전용 메모리에 할당되어 변경할 수 없다.   
또한 문자열 리터럴이 어느 위치에서 사용되는지, 또는 변수 범위가 전역인지 정적인지 로컬인지는 상관 없다.

### 2. 문자열 초기화
문자열을 초기화할 때 어떤 방법을 이용하는지는 문자열 변수가 char 배열로 이루어졌는가 아니면 char* 로 선언되었는가에 따라 다르다.   
문자열에 사용되는 메모리는 배열 또는 포인터가 참조하는 메모리가 된다.   
   
- char 배열 초기화하기   
```c
char arr[] = "hello world";
```
리터럴에 포함된 "hello world"의 길이가 11바이트이므로 총 12바이트가 필요하다.   
arr 배열 원소 하나하나에 저장할 수도 있다.   
   
- char 포인터 초기화하기
```c
char *arr = (char*)malloc(strlen("hello world")+1);
strcpy(arr, "hello world");
```
위와 같은 문자열은 malloc으로 메모리를 할당하고 strcpy를 통해 문자열에 리터럴을 복사한다.   
char 포인터는 문자상수로 초기화할 수 없다. 문자 상수는 정수형이기 때문에, char포인터에 정수를 할당하려는 시도와 같다.   
이렇게 하면 포인터가 역참조될 때 애플리케이션이 비정상 종료된다.
```c
char *arr = (char*)malloc(strlen("hello world")+1);
//위와 같은 표현은 다음과 같이 나타낼 수도 있다.
char *arr = (char*)malloc(12);
```
**malloc 사용시 주의사항**   
* 널 문자를 위해 1바이트 추가로 할당한다.
* 문자열의 길이를 계산할 때 sizeof 연산자를 사용하지 말고 strlen 함수를 이용한다.
* sizeof 연산자는 문자열의 길이가 아닌 배열이나 포인터의 크기를 반환한다.   

- 표준 입력으로 문자열 초기화하기   
문자열은 표준 입력 같은 외부 소스에서 초기화할 수도 있다. 하지만 표준 입력에서 문자열을 입력 받을 떄에는 잠재적인 초기화 오류가 발생할 수 있다.   
이 문제를 해결하려면 포인터에 메모리를 할당하거나 포인터 대신 고정 크기 배열을 사용해야 한다.   
하지만 사용자가 할당된 크기보다 더 큰 데이터를 입력할 수도 있다.   

### 3. 표준 문자열 연산
- 문자열 비교하기(strcmp)   
strcmp함수는 문자열 비교에 표준으로 사용된다.
```c
int strcmp(const char *s1, const char *s2);
//결과값
//음수이면 s1이 s2보다 사전적으로 앞에 있음
//0이면 두 문자열이 동일함
//양수이면 s1이 s2보다 사전적으로 뒤에 있음
```
   
- 문자열 복사하기(strcpy)   
문자열을 복사하기 위해 strcpy를 쓸 수 있다.
```c
char* strcpy(char *s1, const char *s2);
```
일반적인 애플리케이션은 다수의 문자열을 입력받아 각각의 문자열을 최소한의 메모리를 사용하여 배열에 저장한다.   
이때는 사용자가 입력할 수 있는 가장 큰 문자열을 다룰 수 있도록 크기를 지정한 배열을 사용하고, 입력받은 문자열을 배열에 저장한다.
- 문자열을 읽어 들여 큰 char 배열에 저장한다.
- malloc 함수를 이용해 딱 맞는 크기의 메모리를 할당한다.
- strcpy 함수를 이용해 동적으로 할당된 메모리에 문자열을 복사한다.   
두 개의 포인터가 같은 문자열을 참조할 수도 있다. 두 포인터가 같은 위치를 참조할 때, 이를 에일리어싱(aliasing)이라고 부른다.   
하나의 포인터를 다른 포인터에 할당한다고 하더라도 문자열이 복사되는 것이 아님을 주의해야 한다.   
   
- 문자열 연결하기(strcat)
문자열 연결은 두 개의 문자열을 합치는 것이다.
```c
char *strcat(char *s1, const char *s2);
```
이 함수는 두 번째 문자열 s2를 첫 번째 문자열 s1의 뒤에 연결한다. 이 함수는 메모리를 추가로 할당하지 않는다.   
따라서 첫 번째 문자열이 두 번째 문자열을 포함할 수 있을 만큼 충분히 메모리가 할당되어야 한다.   
함수의 반환 값은 첫 번째 인자 s1과 같다.   
   
### 4. 문자열 전달하기
문자열을 전달할 때는 char의 주소 표현을 이용하면 된다.   
- 단순 문자열 전달하기   
```c
size_t stringlen (char* str){
  size_t len = 0;
  while(*(str++)){
    len++;
  }
  return len;
}
```
- 상수 문자에 대한 포인터 전달하기   
문자열에 대한 포인터를 상수문자에 대한 포인터로 전달하는 것은 매우 흔한 일이다.   
이렇게 하면 포인터를 이용해 문자열을 전달하는 동시에 전달된 문자열이 변경되지 않도록 한다.
```c
size_t stringlen (const char* str){
  size_t len = 0;
  while(*(str++)){
    len++;
  }
  return len;
}
```
상수 문자에 대한 포인터로 전달한 경우 원본 문자열을 수정하려고 하면, 컴파일 에러 메시지가 발생한다.   
   
- 애플리케이션에 인자 전달하기   
C언어는 전통적으로 사용되는 argc, argv 매개변수를 통해 실행 인자를 지원한다.   
첫 번째 매개변수인 argv는 몇 개의 실행 인자가 전달되었는지를 알려주는 정수이다. 적어도 하나의 인자는 항상 전달된다.   
```c
int main(int argc, char** argv){
  for(int i=0;i<argc;i++){
    printf("argv[%d] %s\n", i, argv[i]);
  }
  ...
}
```
   
### 5. 문자열 반환하기
함수가 문자열을 반환할 때는 문자열의 주소를 반환한다. 주요 관심사는 유효한 문자열의 주소를 반환하는 것이다.  
그러기 위해 다음 중 하나에 대한 참조를 반환한다.
- 리터럴 문자열
- 동적으로 할당된 메모리
- 로컬 문자열 변수   

< 리터럴 문자열 반환하기 >   
```c
char* Literal(int code){
  switch(code){
    case 100:
      return "Hello";
    case 200:
      return "Happy";
    case 300:
      return "Good bye";
    case 400:
      return "Hi";
  }
}
```
   
< 동적으로 할당된 메모리 주소 반환하기 >   
문자열을 반환해야 하는 함수가 있다면, 문자열의 메모리를 힙에서 할당한 후 그 주소를 반환할 수 있다.   
```c
char* func(int n){
  char* arr = (char*)malloc(n + 1);
  for(int i=0;i<n;i++){
    arr[i] = ' ';
  }
  arr[n] = '\0';
  return arr;
}
...
  char *tmp = func(5);
```
   
< 로컬 문자열의 주소 반환하기 >   
로컬 문자열의 주소를 반환하는 것은, 해당 메모리가 나중에 다른 스택 프레림에 의해 덮어 쓰여 변조될 수 있기 때문이다.   
```c
char* func(int n){
  char arr[32];
  for(int i=0;i<n;i++){
    arr[i] = ' ';
  }
  arr[n] = '\0';
  return arr;
}
```
